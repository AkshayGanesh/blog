{"ast":null,"code":"\"use strict\";\n\n/**\n * @module compiler/main\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\nclass TreeWalker {\n  constructor(consumerFn, arrayWrapper) {\n    this.consumerFn = consumerFn;\n    this.arrayWrapper = arrayWrapper;\n  }\n  /**\n   * Processes the literal node inside schema tree\n   */\n  processLiteralNode(field, node, dotPath, arrayPath) {\n    const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n    return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n  }\n  /**\n   * Process the object node inside the parsed. All children are parsed\n   * recursively\n   */\n  processObjectNode(field, node, dotPath, arrayPath) {\n    let output = [];\n    /**\n     * If object itself has rules, then we need to consume that\n     * as well.\n     */\n    if (node.rules.length) {\n      const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n      output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n    }\n    /**\n     * Walker over object children\n     */\n    output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n    return output;\n  }\n  /**\n   * Process the array node of the schema tree. This method will call\n   * the `arrayWrapper` function and passes all array children to it.\n   */\n  processArrayNode(field, node, dotPath, arrayPath) {\n    let output = [];\n    const basePath = arrayPath.concat(dotPath).concat(field);\n    /**\n     * If array itself has rules, then we need to process that\n     * as well\n     */\n    if (node.rules.length) {\n      const pointer = basePath.join('.');\n      output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n    }\n    /**\n     * Processing children for each index. The index of the tree can be a\n     * wildcard `*`, which means we rely on runtime data to know the\n     * actual length of the array.\n     */\n    Object.keys(node.each).forEach(index => {\n      let child = [];\n      if (node.each[index].rules.length) {\n        const pointer = basePath.concat(index).join('.');\n        child.push(this.consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer));\n      }\n      child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)));\n      output = output.concat(this.arrayWrapper(index, field, child, dotPath));\n    });\n    return output;\n  }\n  /**\n   * Walks the schema tree and invokes the `consumerFn` for each node.\n   * The output of the consumer is collected and returned back as an\n   * array.\n   */\n  walk(schema) {\n    let dotPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let arrayPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    return Object.keys(schema).reduce((result, field) => {\n      const node = schema[field];\n      if (node.type === 'literal') {\n        result = result.concat(this.processLiteralNode(field, node, dotPath, arrayPath));\n      }\n      if (node.type === 'object') {\n        result = result.concat(this.processObjectNode(field, node, dotPath, arrayPath));\n      }\n      if (node.type === 'array') {\n        result = result.concat(this.processArrayNode(field, node, dotPath, arrayPath));\n      }\n      return result;\n    }, []);\n  }\n}\nexports.TreeWalker = TreeWalker;","map":{"version":3,"names":["Object","defineProperty","exports","value","TreeWalker","constructor","consumerFn","arrayWrapper","processLiteralNode","field","node","dotPath","arrayPath","pointer","concat","join","type","rules","processObjectNode","output","length","push","walk","children","processArrayNode","basePath","keys","each","forEach","index","child","schema","arguments","undefined","reduce","result"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-compiler/build/src/TreeWalker/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @module compiler/main\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tree walker is an agnostic implementation to walk over the parsed schema\n * tree generated by `indicative-parser`.\n *\n * The consumer of the code can define a function to consumer the tree nodes and\n * define another function to wrap the children of an array node.\n *\n * ## Why wrap array children?\n * Since the length of an array is unknown, until we receive the data at\n * runtime, we need a parent function (aka wrapper), that can execute\n * the child validations as per the length of the array.\n *\n * ```js\n * function consumerFn (\n *   field: string,\n *   rules: ParsedRule[],\n *   dotPath: string[],\n *   pointer: string,\n * ) {\n * }\n *\n * function arrayWrapper (\n *   index: string,\n *   field: string,\n *   children: ReturnType<consumerFn>[],\n *   dotPath: string[],\n * ) {\n * }\n *\n * new TreeWalker(consumerFn, arrayWrapper).walk(parsedSchema)\n * ```\n */\nclass TreeWalker {\n    constructor(consumerFn, arrayWrapper) {\n        this.consumerFn = consumerFn;\n        this.arrayWrapper = arrayWrapper;\n    }\n    /**\n     * Processes the literal node inside schema tree\n     */\n    processLiteralNode(field, node, dotPath, arrayPath) {\n        const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n        return this.consumerFn(field, node.type, node.rules, dotPath, pointer);\n    }\n    /**\n     * Process the object node inside the parsed. All children are parsed\n     * recursively\n     */\n    processObjectNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        /**\n         * If object itself has rules, then we need to consume that\n         * as well.\n         */\n        if (node.rules.length) {\n            const pointer = arrayPath.concat(dotPath).concat(field).join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Walker over object children\n         */\n        output = output.concat(this.walk(node.children, dotPath.concat(field), arrayPath));\n        return output;\n    }\n    /**\n     * Process the array node of the schema tree. This method will call\n     * the `arrayWrapper` function and passes all array children to it.\n     */\n    processArrayNode(field, node, dotPath, arrayPath) {\n        let output = [];\n        const basePath = arrayPath.concat(dotPath).concat(field);\n        /**\n         * If array itself has rules, then we need to process that\n         * as well\n         */\n        if (node.rules.length) {\n            const pointer = basePath.join('.');\n            output.push(this.consumerFn(field, node.type, node.rules, dotPath, pointer));\n        }\n        /**\n         * Processing children for each index. The index of the tree can be a\n         * wildcard `*`, which means we rely on runtime data to know the\n         * actual length of the array.\n         */\n        Object.keys(node.each).forEach((index) => {\n            let child = [];\n            if (node.each[index].rules.length) {\n                const pointer = basePath.concat(index).join('.');\n                child.push(this.consumerFn('::tip::', 'literal', node.each[index].rules, [], pointer));\n            }\n            child = child.concat(this.walk(node.each[index].children, [], basePath.concat(index)));\n            output = output.concat(this.arrayWrapper(index, field, child, dotPath));\n        });\n        return output;\n    }\n    /**\n     * Walks the schema tree and invokes the `consumerFn` for each node.\n     * The output of the consumer is collected and returned back as an\n     * array.\n     */\n    walk(schema, dotPath = [], arrayPath = []) {\n        return Object.keys(schema).reduce((result, field) => {\n            const node = schema[field];\n            if (node.type === 'literal') {\n                result = result.concat(this.processLiteralNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'object') {\n                result = result.concat(this.processObjectNode(field, node, dotPath, arrayPath));\n            }\n            if (node.type === 'array') {\n                result = result.concat(this.processArrayNode(field, node, dotPath, arrayPath));\n            }\n            return result;\n        }, []);\n    }\n}\nexports.TreeWalker = TreeWalker;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}