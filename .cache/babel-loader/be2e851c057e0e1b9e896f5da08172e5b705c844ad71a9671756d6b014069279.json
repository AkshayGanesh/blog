{"ast":null,"code":"\"use strict\";\n\n/*\n* indicative-parser\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst haye_pipe_1 = __importDefault(require(\"haye/dist/haye-pipe\"));\nconst haye_array_presenter_1 = __importDefault(require(\"haye/dist/haye-array-presenter\"));\nfunction toCamelCase(ruleName) {\n  return ruleName.replace(/_(\\w)/g, (_match, group) => group.toUpperCase());\n}\n/**\n * Updates rules on the given node. If node is missing, then a literal node is\n * created automatically. Literal nodes can later transform into `object` and\n * `array` nodes.\n */\nfunction setLiteral(source, key, rules) {\n  const item = source[key] || {\n    type: 'literal'\n  };\n  item.rules = rules;\n  source[key] = item;\n  return item;\n}\n/**\n * Creates/updates literal node to an object node. Since `object` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an array node, then this method will raise an\n * exception\n */\nfunction setObject(source, key) {\n  if (source[key] && source[key].type === 'array') {\n    throw new Error(`cannot reshape ${key} array to an object`);\n  }\n  const item = source[key] || {\n    rules: []\n  };\n  item.type = 'object';\n  item.children = item.children || {};\n  source[key] = item;\n  return item;\n}\n/**\n * Creates/updates literal node to an array node. Since `array` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an object node, then this method will raise an\n * exception\n */\nfunction setArray(source, key, index) {\n  if (source[key] && source[key].type === 'object') {\n    throw new Error(`cannot reshape ${key} object to an array`);\n  }\n  const item = source[key] || {\n    rules: []\n  };\n  item.each = item.each || {};\n  item.each[index] = item.each[index] || {\n    children: {},\n    rules: []\n  };\n  item.type = 'array';\n  source[key] = item;\n  return item;\n}\n/**\n * Parses field tokens recursively to a [[ParsedSchema]] tree\n */\nfunction parseFieldForRules(tokens, rules, out) {\n  let index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  const token = tokens[index++];\n  /**\n   * Finding if we are on the last item. Last item defines\n   * the rules for the current node inside the tree\n   */\n  const isLast = tokens.length === index;\n  /**\n   * Indexed array have `digits` like `users.0.username`\n   */\n  const isIndexedArray = /^\\d+$/.test(tokens[index]);\n  /**\n   * Is upcoming token an array\n   */\n  const isArray = tokens[index] === '*' || isIndexedArray;\n  /**\n   * Last item was marked as array, since current token is a `*`\n   * or has defined index\n   */\n  if (token === '*' || /^\\d+$/.test(token)) {\n    /**\n     * Last item must update rules for each item for the array\n     */\n    if (isLast) {\n      out.each[token].rules = rules;\n      return;\n    }\n    /**\n     * Nested arrays\n     */\n    if (isArray) {\n      /**\n       * The code after the error works fine. However, in order to support\n       * 2d arrays, we need to implement them inside the declarative\n       * schema and compiler as well.\n       *\n       * For now, it's okay to skip this feature and later work on it\n       * across all the modules.\n       */\n      throw new Error('2d arrays are currently not supported');\n      // const item = setArray(\n      //   (out as SchemaNodeArray).each[token].children,\n      //   token,\n      //   isIndexedArray ? tokens[index] : '*',\n      // )\n      // return parseFieldForRules(tokens, rules, item, index)\n    }\n    /**\n     * Otherwise continue recursion\n     */\n    return parseFieldForRules(tokens, rules, out.each[token].children, index);\n  }\n  /**\n   * Last item in the list of tokens. we must\n   * patch the rules here.\n   */\n  if (isLast) {\n    setLiteral(out, token, rules);\n    return;\n  }\n  /**\n   * Current item as an array\n   */\n  if (isArray) {\n    const item = setArray(out, token, isIndexedArray ? tokens[index] : '*');\n    return parseFieldForRules(tokens, rules, item, index);\n  }\n  /**\n   * Falling back to object\n   */\n  const item = setObject(out, token);\n  return parseFieldForRules(tokens, rules, item.children, index);\n}\n/**\n * Parses the schema object to a tree of parsed schema. The\n * output is optimized for executing validation rules.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username': 'required'\n * })\n *\n * // output\n *\n * {\n *   users: {\n *    type: 'array',\n *    rules: [],\n *    each: {\n *      '*': {\n *        rules: [],\n *        children: {\n *          username: {\n *            type: 'literal',\n *            rules: [{\n *              name: 'required',\n *              args: []\n *            }]\n *          }\n *        }\n *      }\n *    }\n *   }\n * }\n * ```\n */\nfunction rulesParser(schema) {\n  if (schema.schema) {\n    return schema.schema;\n  }\n  return Object.keys(schema).reduce((result, field) => {\n    const rules = schema[field];\n    let parsedRules = [];\n    if (!rules) {\n      throw new Error(`make sure to define rules for ${field}`);\n    }\n    if (typeof rules === 'string') {\n      parsedRules = new haye_pipe_1.default(rules, new haye_array_presenter_1.default()).map(rule => {\n        return {\n          name: toCamelCase(rule.name),\n          args: rule.args\n        };\n      });\n    } else {\n      parsedRules = rules;\n    }\n    parseFieldForRules(field.split('.'), parsedRules, result);\n    return result;\n  }, {});\n}\nexports.rulesParser = rulesParser;\n/**\n * Parses an object of messages to [[ParsedMessages]] list. The messages list\n * is simpler than rules tree, since compiler can use the schema tree to find\n * the appropriate messages from the flat list of messages.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username.required': 'Username is required'\n * })\n *\n * // output\n *\n * {\n *   fields: {\n *    'users.*.username': {\n *      required: 'Username is required'\n *    }\n *   },\n *   rules: {},\n * }\n */\nfunction messagesParser(schema) {\n  return Object.keys(schema).reduce((result, field) => {\n    const message = schema[field];\n    const tokens = field.split('.');\n    const rule = toCamelCase(tokens.pop());\n    /**\n     * If token length is 1, then it is a plain rule vs `field.rule`\n     */\n    if (!tokens.length) {\n      result.rules[rule] = message;\n      return result;\n    }\n    const qualifiedName = tokens.join('.');\n    result.fields[qualifiedName] = result.fields[qualifiedName] || {};\n    result.fields[qualifiedName][rule] = message;\n    return result;\n  }, {\n    fields: {},\n    rules: {}\n  });\n}\nexports.messagesParser = messagesParser;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","haye_pipe_1","require","haye_array_presenter_1","toCamelCase","ruleName","replace","_match","group","toUpperCase","setLiteral","source","key","rules","item","type","setObject","Error","children","setArray","index","each","parseFieldForRules","tokens","out","arguments","length","undefined","token","isLast","isIndexedArray","test","isArray","rulesParser","schema","keys","reduce","result","field","parsedRules","default","map","rule","name","args","split","messagesParser","message","pop","qualifiedName","join","fields"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-parser/build/src/main.js"],"sourcesContent":["\"use strict\";\n/*\n* indicative-parser\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst haye_pipe_1 = __importDefault(require(\"haye/dist/haye-pipe\"));\nconst haye_array_presenter_1 = __importDefault(require(\"haye/dist/haye-array-presenter\"));\nfunction toCamelCase(ruleName) {\n    return ruleName.replace(/_(\\w)/g, (_match, group) => group.toUpperCase());\n}\n/**\n * Updates rules on the given node. If node is missing, then a literal node is\n * created automatically. Literal nodes can later transform into `object` and\n * `array` nodes.\n */\nfunction setLiteral(source, key, rules) {\n    const item = (source[key] || { type: 'literal' });\n    item.rules = rules;\n    source[key] = item;\n    return item;\n}\n/**\n * Creates/updates literal node to an object node. Since `object` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an array node, then this method will raise an\n * exception\n */\nfunction setObject(source, key) {\n    if (source[key] && source[key].type === 'array') {\n        throw new Error(`cannot reshape ${key} array to an object`);\n    }\n    const item = (source[key] || { rules: [] });\n    item.type = 'object';\n    item.children = item.children || {};\n    source[key] = item;\n    return item;\n}\n/**\n * Creates/updates literal node to an array node. Since `array` node\n * properties are different from `literal` node, we need to set those\n * properties (if missing).\n *\n * If node already exists and is an object node, then this method will raise an\n * exception\n */\nfunction setArray(source, key, index) {\n    if (source[key] && source[key].type === 'object') {\n        throw new Error(`cannot reshape ${key} object to an array`);\n    }\n    const item = (source[key] || { rules: [] });\n    item.each = item.each || {};\n    item.each[index] = item.each[index] || { children: {}, rules: [] };\n    item.type = 'array';\n    source[key] = item;\n    return item;\n}\n/**\n * Parses field tokens recursively to a [[ParsedSchema]] tree\n */\nfunction parseFieldForRules(tokens, rules, out, index = 0) {\n    const token = tokens[index++];\n    /**\n     * Finding if we are on the last item. Last item defines\n     * the rules for the current node inside the tree\n     */\n    const isLast = tokens.length === index;\n    /**\n     * Indexed array have `digits` like `users.0.username`\n     */\n    const isIndexedArray = /^\\d+$/.test(tokens[index]);\n    /**\n     * Is upcoming token an array\n     */\n    const isArray = tokens[index] === '*' || isIndexedArray;\n    /**\n     * Last item was marked as array, since current token is a `*`\n     * or has defined index\n     */\n    if (token === '*' || /^\\d+$/.test(token)) {\n        /**\n         * Last item must update rules for each item for the array\n         */\n        if (isLast) {\n            out.each[token].rules = rules;\n            return;\n        }\n        /**\n         * Nested arrays\n         */\n        if (isArray) {\n            /**\n             * The code after the error works fine. However, in order to support\n             * 2d arrays, we need to implement them inside the declarative\n             * schema and compiler as well.\n             *\n             * For now, it's okay to skip this feature and later work on it\n             * across all the modules.\n             */\n            throw new Error('2d arrays are currently not supported');\n            // const item = setArray(\n            //   (out as SchemaNodeArray).each[token].children,\n            //   token,\n            //   isIndexedArray ? tokens[index] : '*',\n            // )\n            // return parseFieldForRules(tokens, rules, item, index)\n        }\n        /**\n         * Otherwise continue recursion\n         */\n        return parseFieldForRules(tokens, rules, out.each[token].children, index);\n    }\n    /**\n     * Last item in the list of tokens. we must\n     * patch the rules here.\n     */\n    if (isLast) {\n        setLiteral(out, token, rules);\n        return;\n    }\n    /**\n     * Current item as an array\n     */\n    if (isArray) {\n        const item = setArray(out, token, isIndexedArray ? tokens[index] : '*');\n        return parseFieldForRules(tokens, rules, item, index);\n    }\n    /**\n     * Falling back to object\n     */\n    const item = setObject(out, token);\n    return parseFieldForRules(tokens, rules, item.children, index);\n}\n/**\n * Parses the schema object to a tree of parsed schema. The\n * output is optimized for executing validation rules.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username': 'required'\n * })\n *\n * // output\n *\n * {\n *   users: {\n *    type: 'array',\n *    rules: [],\n *    each: {\n *      '*': {\n *        rules: [],\n *        children: {\n *          username: {\n *            type: 'literal',\n *            rules: [{\n *              name: 'required',\n *              args: []\n *            }]\n *          }\n *        }\n *      }\n *    }\n *   }\n * }\n * ```\n */\nfunction rulesParser(schema) {\n    if (schema.schema) {\n        return schema.schema;\n    }\n    return Object\n        .keys(schema)\n        .reduce((result, field) => {\n        const rules = schema[field];\n        let parsedRules = [];\n        if (!rules) {\n            throw new Error(`make sure to define rules for ${field}`);\n        }\n        if (typeof (rules) === 'string') {\n            parsedRules = new haye_pipe_1.default(rules, new haye_array_presenter_1.default()).map((rule) => {\n                return { name: toCamelCase(rule.name), args: rule.args };\n            });\n        }\n        else {\n            parsedRules = rules;\n        }\n        parseFieldForRules(field.split('.'), parsedRules, result);\n        return result;\n    }, {});\n}\nexports.rulesParser = rulesParser;\n/**\n * Parses an object of messages to [[ParsedMessages]] list. The messages list\n * is simpler than rules tree, since compiler can use the schema tree to find\n * the appropriate messages from the flat list of messages.\n *\n * @example\n * ```\n * parser({\n *  'users.*.username.required': 'Username is required'\n * })\n *\n * // output\n *\n * {\n *   fields: {\n *    'users.*.username': {\n *      required: 'Username is required'\n *    }\n *   },\n *   rules: {},\n * }\n */\nfunction messagesParser(schema) {\n    return Object\n        .keys(schema)\n        .reduce((result, field) => {\n        const message = schema[field];\n        const tokens = field.split('.');\n        const rule = toCamelCase(tokens.pop());\n        /**\n         * If token length is 1, then it is a plain rule vs `field.rule`\n         */\n        if (!tokens.length) {\n            result.rules[rule] = message;\n            return result;\n        }\n        const qualifiedName = tokens.join('.');\n        result.fields[qualifiedName] = result.fields[qualifiedName] || {};\n        result.fields[qualifiedName][rule] = message;\n        return result;\n    }, { fields: {}, rules: {} });\n}\nexports.messagesParser = messagesParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}