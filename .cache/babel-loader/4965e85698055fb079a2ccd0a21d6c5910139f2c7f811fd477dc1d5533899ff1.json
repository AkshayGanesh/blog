{"ast":null,"code":"\"use strict\";\n\n/**\n * @module compiler/validator\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\nclass ArrayWrapper {\n  constructor(field, index, childrenValidators, dotPath) {\n    this.field = field;\n    this.index = index;\n    this.childrenValidators = childrenValidators;\n    this.dotPath = dotPath;\n    /**\n     * The pointer to read the value of the field inside the data tip\n     */\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    /**\n     * A boolean to know if any of the children inside the wrapper\n     * has async validators.\n     */\n    this.async = !!this.childrenValidators.find(validator => validator.async);\n  }\n  /**\n   * Returns data copy to the passed to all the children of the\n   * array.\n   */\n  getDataCopy(data) {\n    const value = lodash_get_1.default(data.tip, this.pointer);\n    /**\n     * Ensure value is array, otherwise mark the validation as passed.\n     * The top level value must be validated for an array for same.\n     */\n    if (!Array.isArray(value)) {\n      return null;\n    }\n    /**\n     * Since we are adding new properties to the data object. We have\n     * to create a new copy, otherwise the array specific values\n     * will leak this info to other validations as well.\n     */\n    return {\n      original: data.original,\n      pointer: '',\n      tip: null,\n      parentArray: value,\n      currentIndex: this.index === '*' ? 0 : Number(this.index),\n      arrayPointer: data.arrayPointer ? `${data.arrayPointer}.${data.currentIndex}.${this.pointer}` : this.pointer\n    };\n  }\n  /**\n   * Executes all validations for a given index value inside the array.\n   */\n  executeValidations(data, collector, config, bail) {\n    let hasFailures = false;\n    for (let validator of this.childrenValidators) {\n      const passed = validator.exec(data, collector, config, bail);\n      if (!passed) {\n        hasFailures = true;\n        if (bail) {\n          break;\n        }\n      }\n    }\n    return !hasFailures;\n  }\n  /**\n   * Same as [[ArrayWrapper.executeValidations]] but async.\n   */\n  async executeAsyncValidations(data, collector, config, bail) {\n    let hasFailures = false;\n    for (let validator of this.childrenValidators) {\n      let passed = true;\n      if (validator.async) {\n        passed = await validator.execAsync(data, collector, config, bail);\n      } else {\n        passed = validator.exec(data, collector, config, bail);\n      }\n      if (!passed) {\n        hasFailures = true;\n        if (bail) {\n          break;\n        }\n      }\n    }\n    return !hasFailures;\n  }\n  /**\n   * Execute series of validations for values inside an array\n   */\n  exec(data, collector, config) {\n    let bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const dataCopy = this.getDataCopy(data);\n    if (!dataCopy) {\n      return true;\n    }\n    /**\n     * If index is a not a wildcard, then we run validations\n     * just for the given index.\n     */\n    if (this.index !== '*') {\n      dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n      return this.executeValidations(dataCopy, collector, config, bail);\n    }\n    let index = 0;\n    let hasFailures = false;\n    /**\n     * Loop over all the entire array and execute validations\n     * for each field.\n     */\n    for (let item of dataCopy.parentArray) {\n      dataCopy.tip = item;\n      dataCopy.currentIndex = index;\n      let passed = true;\n      passed = this.executeValidations(dataCopy, collector, config, bail);\n      if (!passed) {\n        hasFailures = true;\n        if (bail) {\n          break;\n        }\n      }\n      index++;\n    }\n    return !hasFailures;\n  }\n  /**\n   * Execute series of async validations for values inside an array. Same\n   * as [[ArrayWrapper.exec]] but async.\n   */\n  async execAsync(data, collector, config) {\n    let bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const dataCopy = this.getDataCopy(data);\n    if (!dataCopy) {\n      return true;\n    }\n    /**\n     * If index is a not a wildcard, then we run validations\n     * just for the given index.\n     */\n    if (this.index !== '*') {\n      dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n      return this.executeAsyncValidations(dataCopy, collector, config, bail);\n    }\n    let index = 0;\n    let hasFailures = false;\n    /**\n     * Loop over all the entire array and execute validations\n     * for each field.\n     */\n    for (let item of dataCopy.parentArray) {\n      dataCopy.tip = item;\n      dataCopy.currentIndex = index;\n      const passed = await this.executeAsyncValidations(dataCopy, collector, config, bail);\n      if (!passed) {\n        hasFailures = true;\n        if (bail) {\n          break;\n        }\n      }\n      index++;\n    }\n    return !hasFailures;\n  }\n}\nexports.ArrayWrapper = ArrayWrapper;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","lodash_get_1","require","ArrayWrapper","constructor","field","index","childrenValidators","dotPath","pointer","concat","join","async","find","validator","getDataCopy","data","default","tip","Array","isArray","original","parentArray","currentIndex","Number","arrayPointer","executeValidations","collector","config","bail","hasFailures","passed","exec","executeAsyncValidations","execAsync","arguments","length","undefined","dataCopy","item"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-compiler/build/src/Validator/ArrayWrapper.js"],"sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Wraps the [[ValidationsRunner]] and executes them based upon the length of\n * an array at runtime.\n */\nclass ArrayWrapper {\n    constructor(field, index, childrenValidators, dotPath) {\n        this.field = field;\n        this.index = index;\n        this.childrenValidators = childrenValidators;\n        this.dotPath = dotPath;\n        /**\n         * The pointer to read the value of the field inside the data tip\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        /**\n         * A boolean to know if any of the children inside the wrapper\n         * has async validators.\n         */\n        this.async = !!this.childrenValidators.find((validator) => validator.async);\n    }\n    /**\n     * Returns data copy to the passed to all the children of the\n     * array.\n     */\n    getDataCopy(data) {\n        const value = lodash_get_1.default(data.tip, this.pointer);\n        /**\n         * Ensure value is array, otherwise mark the validation as passed.\n         * The top level value must be validated for an array for same.\n         */\n        if (!Array.isArray(value)) {\n            return null;\n        }\n        /**\n         * Since we are adding new properties to the data object. We have\n         * to create a new copy, otherwise the array specific values\n         * will leak this info to other validations as well.\n         */\n        return {\n            original: data.original,\n            pointer: '',\n            tip: null,\n            parentArray: value,\n            currentIndex: this.index === '*' ? 0 : Number(this.index),\n            arrayPointer: data.arrayPointer\n                ? `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`\n                : this.pointer,\n        };\n    }\n    /**\n     * Executes all validations for a given index value inside the array.\n     */\n    executeValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            const passed = validator.exec(data, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Same as [[ArrayWrapper.executeValidations]] but async.\n     */\n    async executeAsyncValidations(data, collector, config, bail) {\n        let hasFailures = false;\n        for (let validator of this.childrenValidators) {\n            let passed = true;\n            if (validator.async) {\n                passed = await validator.execAsync(data, collector, config, bail);\n            }\n            else {\n                passed = validator.exec(data, collector, config, bail);\n            }\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of validations for values inside an array\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            let passed = true;\n            passed = this.executeValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n    /**\n     * Execute series of async validations for values inside an array. Same\n     * as [[ArrayWrapper.exec]] but async.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        if (!dataCopy) {\n            return true;\n        }\n        /**\n         * If index is a not a wildcard, then we run validations\n         * just for the given index.\n         */\n        if (this.index !== '*') {\n            dataCopy.tip = dataCopy.parentArray[dataCopy.currentIndex];\n            return this.executeAsyncValidations(dataCopy, collector, config, bail);\n        }\n        let index = 0;\n        let hasFailures = false;\n        /**\n         * Loop over all the entire array and execute validations\n         * for each field.\n         */\n        for (let item of dataCopy.parentArray) {\n            dataCopy.tip = item;\n            dataCopy.currentIndex = index;\n            const passed = await this.executeAsyncValidations(dataCopy, collector, config, bail);\n            if (!passed) {\n                hasFailures = true;\n                if (bail) {\n                    break;\n                }\n            }\n            index++;\n        }\n        return !hasFailures;\n    }\n}\nexports.ArrayWrapper = ArrayWrapper;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}