{"ast":null,"code":"\"use strict\";\n\n/*\n* indicative-rules\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst indicative_utils_1 = require(\"indicative-utils\");\nconst dateFormat_1 = require(\"../../raw/dateFormat\");\nconst MISSING_VALUE = 'dateFormat:make sure to define atleast one date format';\n/**\n * Ensures the date or date time is valid as the per the defined formats.\n *\n * This method will import [format](https://date-fns.org/v1.29.0/docs/format) method from dateFns.\n *\n * ### Note\n * Following steps are performed to strip the timezone from the actual date\n * and then format the date. Keeping timezones will result in different\n * output, even when the format is correct.\n *\n * 1. Timezone is only stripped when the date format expects timezone to\n *    be present.\n * 2. `Z` and `ZZ` identifiers replaces their expected counter parts.\n * 3. Also date can have `Z`, which is equivalent to `+00:00`.\n * 4. If we will not strip the timezone offset from the actual date, then\n *    dateFns will format it in local timezone causing invalid date\n *    comparison.\n * 5. Validation will also fail, when format expects a timezone but missing\n *    in original date.\n *\n * ```ts\n * import { validations } from 'indicative/validator'\n *\n * const rules = {\n *   publish_at: [\n *     validations.dateFormat(['YYYY-MM-DD HH:mm:ss'])\n *   ]\n * }\n * ```\n */\nconst validation = {\n  async: false,\n  compile(args) {\n    indicative_utils_1.ensureLength(args, MISSING_VALUE, 1);\n    return args.map(arg => String(arg));\n  },\n  validate: (data, field, args, config) => {\n    const fieldValue = indicative_utils_1.getValue(data, field);\n    return indicative_utils_1.skippable(fieldValue, field, config) || dateFormat_1.dateFormat(fieldValue, args);\n  }\n};\nexports.default = validation;","map":{"version":3,"names":["Object","defineProperty","exports","value","indicative_utils_1","require","dateFormat_1","MISSING_VALUE","validation","async","compile","args","ensureLength","map","arg","String","validate","data","field","config","fieldValue","getValue","skippable","dateFormat","default"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-rules/build/src/validations/date-string/dateFormat.js"],"sourcesContent":["\"use strict\";\n/*\n* indicative-rules\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst indicative_utils_1 = require(\"indicative-utils\");\nconst dateFormat_1 = require(\"../../raw/dateFormat\");\nconst MISSING_VALUE = 'dateFormat:make sure to define atleast one date format';\n/**\n * Ensures the date or date time is valid as the per the defined formats.\n *\n * This method will import [format](https://date-fns.org/v1.29.0/docs/format) method from dateFns.\n *\n * ### Note\n * Following steps are performed to strip the timezone from the actual date\n * and then format the date. Keeping timezones will result in different\n * output, even when the format is correct.\n *\n * 1. Timezone is only stripped when the date format expects timezone to\n *    be present.\n * 2. `Z` and `ZZ` identifiers replaces their expected counter parts.\n * 3. Also date can have `Z`, which is equivalent to `+00:00`.\n * 4. If we will not strip the timezone offset from the actual date, then\n *    dateFns will format it in local timezone causing invalid date\n *    comparison.\n * 5. Validation will also fail, when format expects a timezone but missing\n *    in original date.\n *\n * ```ts\n * import { validations } from 'indicative/validator'\n *\n * const rules = {\n *   publish_at: [\n *     validations.dateFormat(['YYYY-MM-DD HH:mm:ss'])\n *   ]\n * }\n * ```\n */\nconst validation = {\n    async: false,\n    compile(args) {\n        indicative_utils_1.ensureLength(args, MISSING_VALUE, 1);\n        return args.map((arg) => String(arg));\n    },\n    validate: (data, field, args, config) => {\n        const fieldValue = indicative_utils_1.getValue(data, field);\n        return indicative_utils_1.skippable(fieldValue, field, config) || dateFormat_1.dateFormat(fieldValue, args);\n    },\n};\nexports.default = validation;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMC,kBAAkB,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AACtD,MAAMC,YAAY,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAME,aAAa,GAAG,wDAAwD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,GAAG;EACfC,KAAK,EAAE,KAAK;EACZC,OAAOA,CAACC,IAAI,EAAE;IACVP,kBAAkB,CAACQ,YAAY,CAACD,IAAI,EAAEJ,aAAa,EAAE,CAAC,CAAC;IACvD,OAAOI,IAAI,CAACE,GAAG,CAAEC,GAAG,IAAKC,MAAM,CAACD,GAAG,CAAC,CAAC;EACzC,CAAC;EACDE,QAAQ,EAAEA,CAACC,IAAI,EAAEC,KAAK,EAAEP,IAAI,EAAEQ,MAAM,KAAK;IACrC,MAAMC,UAAU,GAAGhB,kBAAkB,CAACiB,QAAQ,CAACJ,IAAI,EAAEC,KAAK,CAAC;IAC3D,OAAOd,kBAAkB,CAACkB,SAAS,CAACF,UAAU,EAAEF,KAAK,EAAEC,MAAM,CAAC,IAAIb,YAAY,CAACiB,UAAU,CAACH,UAAU,EAAET,IAAI,CAAC;EAC/G;AACJ,CAAC;AACDT,OAAO,CAACsB,OAAO,GAAGhB,UAAU"},"metadata":{},"sourceType":"script","externalDependencies":[]}