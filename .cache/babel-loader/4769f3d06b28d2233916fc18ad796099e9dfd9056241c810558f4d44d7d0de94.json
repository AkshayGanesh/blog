{"ast":null,"code":"\"use strict\";\n\n/**\n * @module compiler/validator\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\nclass ValidationsRunner {\n  constructor(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n    this.field = field;\n    this.type = type;\n    this.dotPath = dotPath;\n    this.fieldMessages = fieldMessages;\n    this.genericMessages = genericMessages;\n    /**\n     * We toggle this flag then creating the `validations` object\n     */\n    this.async = false;\n    /**\n     * Collection of validations to be executed on a given field.\n     */\n    this.validations = [];\n    /**\n     * Base pointer to this field. When field is inside an\n     * array, then we need to re-compute the pointer\n     * based upon the current index in which this\n     * field is validated.\n     *\n     * However, we don't mutate this field.\n     */\n    this.pointer = this.dotPath.concat(this.field).join('.');\n    this.computeValidations(validations, rules);\n  }\n  /**\n   * Creating a list of validation functions to be executed as per\n   * the defined rules.\n   */\n  computeValidations(validations, rules) {\n    this.validations = rules.map(rule => {\n      const validation = validations[rule.name];\n      /**\n       * Raise exception when validation implementation for a\n       * given rule is missing.\n       */\n      if (!validation) {\n        throw new Error(`${rule.name} is not a registered as a validation`);\n      }\n      /**\n       * The validation node must have a `validate` function.\n       */\n      if (typeof validation.validate !== 'function') {\n        throw new Error(`${rule.name} is missing validate function`);\n      }\n      /**\n       * Mutate args when `compile` function is defined. It is a way to\n       * normalize arguments before the validation process kicks in.\n       */\n      if (typeof validation.compile === 'function') {\n        rule.args = validation.compile(rule.args);\n      }\n      /**\n       * Set the flag to `true` when one or more validations are `async`.\n       * This tells the consumer of [[ValidationsRunner]] class to make\n       * use of `execAsync` over `exec`. All done for performance.\n       */\n      if (validation.async) {\n        this.async = true;\n      }\n      return {\n        rule: rule,\n        fn: validation.validate,\n        async: validation.async\n      };\n    });\n  }\n  /**\n   * Returns a fresh data copy by copying some of the values from the actual\n   * data and then mutating the `tip` and `pointer`. The tip and pointer\n   * are mutated so that the validation function receives the closest\n   * object from the pointer, resulting in performant code.\n   */\n  getDataCopy(data) {\n    const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n    /**\n     * Prefix array pointer and current index, when this field is part\n     * of an array.\n     * Also do not append the pointer when pointer is `::tip::`\n     */\n    const pointer = data.arrayPointer ? this.pointer === '::tip::' ? `${data.arrayPointer}.${data.currentIndex}` : `${data.arrayPointer}.${data.currentIndex}.${this.pointer}` : this.pointer;\n    /**\n     * Updating the tip and pointer\n     */\n    return Object.assign({}, data, {\n      tip: this.field === '::tip::' ? {\n        [this.field]: tip\n      } : tip,\n      pointer: pointer\n    });\n  }\n  /**\n   * Reports value to the collector when current field is a literal\n   * node inside the tree and validation has passed\n   */\n  reportValueToCollector(passed, data, collector) {\n    if (!passed || this.type !== 'literal') {\n      return;\n    }\n    collector.setValue(data.pointer, data.tip[this.field]);\n  }\n  /**\n   * Reports the validation error to the collector.\n   */\n  reportErrorToCollector(pointer, rule, collector, exception) {\n    const message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n    collector.setError(pointer, rule, message);\n  }\n  /**\n   * Executes all the validations on a given field synchronously. Run\n   * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n   */\n  exec(data, collector, config) {\n    let bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n    if (!isobject_1.default(dataCopy.tip)) {\n      return true;\n    }\n    let hasFailures = false;\n    /**\n     * Sequentially loop over all the validations.\n     * We break the loop, when `bail=true`.\n     */\n    for (let validation of this.validations) {\n      let exception = null;\n      let passed = true;\n      /**\n       * Wrapping the validation function for unexpected errors.\n       */\n      try {\n        passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n      } catch (error) {\n        exception = error;\n        passed = false;\n      }\n      if (!passed) {\n        hasFailures = true;\n        this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n        if (bail) {\n          break;\n        }\n      }\n    }\n    this.reportValueToCollector(!hasFailures, dataCopy, collector);\n    return !hasFailures;\n  }\n  /**\n   * Executes all the validations on a given field asynchronously. Run\n   * [[ValidationsRunner.exec]] if want to execute synchronously.\n   */\n  async execAsync(data, collector, config) {\n    let bail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n    if (!isobject_1.default(dataCopy.tip)) {\n      return true;\n    }\n    let hasFailures = false;\n    /**\n     * Sequentially loop over all the validations.\n     * We break the loop, when `bail=true`.\n     */\n    for (let validation of this.validations) {\n      let exception = null;\n      let passed = true;\n      try {\n        if (validation.async) {\n          passed = await validation.fn(dataCopy, this.field, validation.rule.args, config);\n        } else {\n          passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n        }\n      } catch (error) {\n        passed = false;\n        exception = error;\n      }\n      if (!passed) {\n        hasFailures = true;\n        this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n        if (bail) {\n          break;\n        }\n      }\n    }\n    this.reportValueToCollector(!hasFailures, dataCopy, collector);\n    return !hasFailures;\n  }\n}\nexports.ValidationsRunner = ValidationsRunner;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","ValidationsRunner","constructor","field","type","dotPath","rules","validations","fieldMessages","genericMessages","async","pointer","concat","join","computeValidations","map","rule","validation","name","Error","validate","compile","args","fn","getDataCopy","data","tip","length","default","arrayPointer","currentIndex","assign","reportValueToCollector","passed","collector","setValue","reportErrorToCollector","exception","message","setError","exec","config","bail","arguments","undefined","dataCopy","hasFailures","error","execAsync"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-compiler/build/src/Validator/ValidationsRunner.js"],"sourcesContent":["\"use strict\";\n/**\n * @module compiler/validator\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs a series of validations on a given field. This class is feeded with the\n * computed nodes generated via [[TreeWalker]].\n */\nclass ValidationsRunner {\n    constructor(field, type, dotPath, rules, validations, fieldMessages, genericMessages) {\n        this.field = field;\n        this.type = type;\n        this.dotPath = dotPath;\n        this.fieldMessages = fieldMessages;\n        this.genericMessages = genericMessages;\n        /**\n         * We toggle this flag then creating the `validations` object\n         */\n        this.async = false;\n        /**\n         * Collection of validations to be executed on a given field.\n         */\n        this.validations = [];\n        /**\n         * Base pointer to this field. When field is inside an\n         * array, then we need to re-compute the pointer\n         * based upon the current index in which this\n         * field is validated.\n         *\n         * However, we don't mutate this field.\n         */\n        this.pointer = this.dotPath.concat(this.field).join('.');\n        this.computeValidations(validations, rules);\n    }\n    /**\n     * Creating a list of validation functions to be executed as per\n     * the defined rules.\n     */\n    computeValidations(validations, rules) {\n        this.validations = rules.map((rule) => {\n            const validation = validations[rule.name];\n            /**\n             * Raise exception when validation implementation for a\n             * given rule is missing.\n             */\n            if (!validation) {\n                throw new Error(`${rule.name} is not a registered as a validation`);\n            }\n            /**\n             * The validation node must have a `validate` function.\n             */\n            if (typeof (validation.validate) !== 'function') {\n                throw new Error(`${rule.name} is missing validate function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the validation process kicks in.\n             */\n            if (typeof (validation.compile) === 'function') {\n                rule.args = validation.compile(rule.args);\n            }\n            /**\n             * Set the flag to `true` when one or more validations are `async`.\n             * This tells the consumer of [[ValidationsRunner]] class to make\n             * use of `execAsync` over `exec`. All done for performance.\n             */\n            if (validation.async) {\n                this.async = true;\n            }\n            return { rule: rule, fn: validation.validate, async: validation.async };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the validation function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Prefix array pointer and current index, when this field is part\n         * of an array.\n         * Also do not append the pointer when pointer is `::tip::`\n         */\n        const pointer = data.arrayPointer ?\n            (this.pointer === '::tip::'\n                ? `${data.arrayPointer}.${data.currentIndex}`\n                : `${data.arrayPointer}.${data.currentIndex}.${this.pointer}`)\n            : this.pointer;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n            pointer: pointer,\n        });\n    }\n    /**\n     * Reports value to the collector when current field is a literal\n     * node inside the tree and validation has passed\n     */\n    reportValueToCollector(passed, data, collector) {\n        if (!passed || this.type !== 'literal') {\n            return;\n        }\n        collector.setValue(data.pointer, data.tip[this.field]);\n    }\n    /**\n     * Reports the validation error to the collector.\n     */\n    reportErrorToCollector(pointer, rule, collector, exception) {\n        const message = exception || this.fieldMessages[rule.name] || this.genericMessages[rule.name];\n        collector.setError(pointer, rule, message);\n    }\n    /**\n     * Executes all the validations on a given field synchronously. Run\n     * [[ValidationsRunner.execAsync]] if want to execute asynchronously.\n     */\n    exec(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            /**\n             * Wrapping the validation function for unexpected errors.\n             */\n            try {\n                passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n            }\n            catch (error) {\n                exception = error;\n                passed = false;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n    /**\n     * Executes all the validations on a given field asynchronously. Run\n     * [[ValidationsRunner.exec]] if want to execute synchronously.\n     */\n    async execAsync(data, collector, config, bail = false) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return true;\n        }\n        let hasFailures = false;\n        /**\n         * Sequentially loop over all the validations.\n         * We break the loop, when `bail=true`.\n         */\n        for (let validation of this.validations) {\n            let exception = null;\n            let passed = true;\n            try {\n                if (validation.async) {\n                    passed = await validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n                else {\n                    passed = validation.fn(dataCopy, this.field, validation.rule.args, config);\n                }\n            }\n            catch (error) {\n                passed = false;\n                exception = error;\n            }\n            if (!passed) {\n                hasFailures = true;\n                this.reportErrorToCollector(dataCopy.pointer, validation.rule, collector, exception);\n                if (bail) {\n                    break;\n                }\n            }\n        }\n        this.reportValueToCollector(!hasFailures, dataCopy, collector);\n        return !hasFailures;\n    }\n}\nexports.ValidationsRunner = ValidationsRunner;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}