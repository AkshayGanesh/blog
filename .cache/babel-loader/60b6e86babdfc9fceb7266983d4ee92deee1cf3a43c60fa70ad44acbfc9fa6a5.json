{"ast":null,"code":"\"use strict\";\n\n/**\n * @module indicative\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n* indicative\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nconst indicative_rules_1 = require(\"indicative-rules\");\nconst indicative_compiler_1 = require(\"indicative-compiler\");\nconst CacheManager_1 = require(\"../CacheManager\");\nconst config_1 = require(\"./config\");\nconst cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\nfunction getExecutor(schema, messages, config) {\n  /**\n   * Always compile schema, when there is no cacheKey\n   */\n  if (!config.cacheKey) {\n    const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n    return new indicative_compiler_1.ValidatorExecutor(compiler.compile());\n  }\n  /**\n   * Pre-compile the schema and set it as cache when it's not\n   * inside the cache already\n   */\n  const compiledSchema = cacheManager.get(config.cacheKey);\n  if (!compiledSchema) {\n    const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n    cacheManager.set(config.cacheKey, compiler.compile());\n  }\n  return new indicative_compiler_1.ValidatorExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Validates the given data set against the defined schema. The validator\n * stops at the first error. You must use [[validateAll]] to continue\n * validations, even after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validate = (data, schema, messages, config) => {\n  config = Object.assign({}, config_1.config, config);\n  return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, true, config.removeAdditional, config.customErrorCollector);\n};\n/**\n * Validates the given data set against the defined schema. The validator\n * continues even after errors. You must use [[validate]] to stop\n * validations after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validateAll = (data, schema, messages, config) => {\n  config = Object.assign({}, config_1.config, config);\n  return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, false, config.removeAdditional, config.customErrorCollector);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","indicative_rules_1","require","indicative_compiler_1","CacheManager_1","config_1","cacheManager","CacheManager","getExecutor","schema","messages","config","cacheKey","compiler","ValidatorCompiler","validations","ValidatorExecutor","compile","compiledSchema","get","set","validate","data","assign","exec","formatter","removeAdditional","customErrorCollector","validateAll"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative/src/Validator/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @module indicative\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n* indicative\n*\n* (c) Harminder Virk <virk@adonisjs.com>\n*\n* For the full copyright and license information, please view the LICENSE\n* file that was distributed with this source code.\n*/\nconst indicative_rules_1 = require(\"indicative-rules\");\nconst indicative_compiler_1 = require(\"indicative-compiler\");\nconst CacheManager_1 = require(\"../CacheManager\");\nconst config_1 = require(\"./config\");\nconst cacheManager = new CacheManager_1.CacheManager();\n/**\n * Returns executor by pre-compiling and optionally caching schema.\n */\nfunction getExecutor(schema, messages, config) {\n    /**\n     * Always compile schema, when there is no cacheKey\n     */\n    if (!config.cacheKey) {\n        const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n        return new indicative_compiler_1.ValidatorExecutor(compiler.compile());\n    }\n    /**\n     * Pre-compile the schema and set it as cache when it's not\n     * inside the cache already\n     */\n    const compiledSchema = cacheManager.get(config.cacheKey);\n    if (!compiledSchema) {\n        const compiler = new indicative_compiler_1.ValidatorCompiler(schema, messages, indicative_rules_1.validations);\n        cacheManager.set(config.cacheKey, compiler.compile());\n    }\n    return new indicative_compiler_1.ValidatorExecutor(cacheManager.get(config.cacheKey));\n}\n/**\n * Validates the given data set against the defined schema. The validator\n * stops at the first error. You must use [[validateAll]] to continue\n * validations, even after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validate = (data, schema, messages, config) => {\n    config = Object.assign({}, config_1.config, config);\n    return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, true, config.removeAdditional, config.customErrorCollector);\n};\n/**\n * Validates the given data set against the defined schema. The validator\n * continues even after errors. You must use [[validate]] to stop\n * validations after first error.\n *\n * It is recommended to define the `config` cacheKey to avoid\n * re-compiling the same schema again and again.\n */\nexports.validateAll = (data, schema, messages, config) => {\n    config = Object.assign({}, config_1.config, config);\n    return getExecutor(schema, messages || {}, config).exec(data, config.formatter, config, false, config.removeAdditional, config.customErrorCollector);\n};\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AACtD,MAAMC,qBAAqB,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC5D,MAAME,cAAc,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AACjD,MAAMG,QAAQ,GAAGH,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMI,YAAY,GAAG,IAAIF,cAAc,CAACG,YAAY,CAAC,CAAC;AACtD;AACA;AACA;AACA,SAASC,WAAWA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EAC3C;AACJ;AACA;EACI,IAAI,CAACA,MAAM,CAACC,QAAQ,EAAE;IAClB,MAAMC,QAAQ,GAAG,IAAIV,qBAAqB,CAACW,iBAAiB,CAACL,MAAM,EAAEC,QAAQ,EAAET,kBAAkB,CAACc,WAAW,CAAC;IAC9G,OAAO,IAAIZ,qBAAqB,CAACa,iBAAiB,CAACH,QAAQ,CAACI,OAAO,CAAC,CAAC,CAAC;EAC1E;EACA;AACJ;AACA;AACA;EACI,MAAMC,cAAc,GAAGZ,YAAY,CAACa,GAAG,CAACR,MAAM,CAACC,QAAQ,CAAC;EACxD,IAAI,CAACM,cAAc,EAAE;IACjB,MAAML,QAAQ,GAAG,IAAIV,qBAAqB,CAACW,iBAAiB,CAACL,MAAM,EAAEC,QAAQ,EAAET,kBAAkB,CAACc,WAAW,CAAC;IAC9GT,YAAY,CAACc,GAAG,CAACT,MAAM,CAACC,QAAQ,EAAEC,QAAQ,CAACI,OAAO,CAAC,CAAC,CAAC;EACzD;EACA,OAAO,IAAId,qBAAqB,CAACa,iBAAiB,CAACV,YAAY,CAACa,GAAG,CAACR,MAAM,CAACC,QAAQ,CAAC,CAAC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAb,OAAO,CAACsB,QAAQ,GAAG,CAACC,IAAI,EAAEb,MAAM,EAAEC,QAAQ,EAAEC,MAAM,KAAK;EACnDA,MAAM,GAAGd,MAAM,CAAC0B,MAAM,CAAC,CAAC,CAAC,EAAElB,QAAQ,CAACM,MAAM,EAAEA,MAAM,CAAC;EACnD,OAAOH,WAAW,CAACC,MAAM,EAAEC,QAAQ,IAAI,CAAC,CAAC,EAAEC,MAAM,CAAC,CAACa,IAAI,CAACF,IAAI,EAAEX,MAAM,CAACc,SAAS,EAAEd,MAAM,EAAE,IAAI,EAAEA,MAAM,CAACe,gBAAgB,EAAEf,MAAM,CAACgB,oBAAoB,CAAC;AACvJ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5B,OAAO,CAAC6B,WAAW,GAAG,CAACN,IAAI,EAAEb,MAAM,EAAEC,QAAQ,EAAEC,MAAM,KAAK;EACtDA,MAAM,GAAGd,MAAM,CAAC0B,MAAM,CAAC,CAAC,CAAC,EAAElB,QAAQ,CAACM,MAAM,EAAEA,MAAM,CAAC;EACnD,OAAOH,WAAW,CAACC,MAAM,EAAEC,QAAQ,IAAI,CAAC,CAAC,EAAEC,MAAM,CAAC,CAACa,IAAI,CAACF,IAAI,EAAEX,MAAM,CAACc,SAAS,EAAEd,MAAM,EAAE,KAAK,EAAEA,MAAM,CAACe,gBAAgB,EAAEf,MAAM,CAACgB,oBAAoB,CAAC;AACxJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}