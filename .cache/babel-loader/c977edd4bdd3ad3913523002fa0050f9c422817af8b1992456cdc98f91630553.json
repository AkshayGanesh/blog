{"ast":null,"code":"\"use strict\";\n\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\nclass SanitizationsRunner {\n  constructor(field, dotPath, rules, sanitizations) {\n    this.field = field;\n    this.dotPath = dotPath;\n    this.sanitizations = [];\n    this.computeSanitizations(sanitizations, rules);\n  }\n  /**\n   * Pull sanitizations for the list defined rules.\n   */\n  computeSanitizations(sanitizations, rules) {\n    this.sanitizations = rules.map(rule => {\n      const sanitization = sanitizations[rule.name];\n      /**\n       * Raise exception when sanitization implementation for a\n       * given rule is missing.\n       */\n      if (!sanitization) {\n        throw new Error(`${rule.name} is not a registered as a sanitization`);\n      }\n      /**\n       * The sanitization node must have a `validate` function.\n       */\n      if (typeof sanitization.sanitize !== 'function') {\n        throw new Error(`${rule.name} is missing sanitize function`);\n      }\n      /**\n       * Mutate args when `compile` function is defined. It is a way to\n       * normalize arguments before the sanitization process kicks in.\n       */\n      if (typeof sanitization.compile === 'function') {\n        rule.args = sanitization.compile(rule.args);\n      }\n      return {\n        rule: rule,\n        fn: sanitization.sanitize\n      };\n    });\n  }\n  /**\n   * Returns a fresh data copy by copying some of the values from the actual\n   * data and then mutating the `tip` and `pointer`. The tip and pointer\n   * are mutated so that the sanitization function receives the closest\n   * object from the pointer, resulting in performant code.\n   */\n  getDataCopy(data) {\n    const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n    /**\n     * Updating the tip and pointer\n     */\n    return Object.assign({}, data, {\n      tip: this.field === '::tip::' ? {\n        [this.field]: tip\n      } : tip\n    });\n  }\n  /**\n   * Execute all sanitization in series for a given filed\n   */\n  exec(data, config) {\n    const dataCopy = this.getDataCopy(data);\n    /**\n     * Skip validations when the parent value of this field is not\n     * an object. The user must validate the parent to be object\n     * seperately.\n     */\n    if (!isobject_1.default(dataCopy.tip)) {\n      return;\n    }\n    this.sanitizations.forEach(sanitization => {\n      sanitization.fn(dataCopy, this.field, sanitization.rule.args, config);\n    });\n  }\n}\nexports.SanitizationsRunner = SanitizationsRunner;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","isobject_1","require","lodash_get_1","SanitizationsRunner","constructor","field","dotPath","rules","sanitizations","computeSanitizations","map","rule","sanitization","name","Error","sanitize","compile","args","fn","getDataCopy","data","tip","length","default","assign","exec","config","dataCopy","forEach"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/indicative-compiler/build/src/Sanitizer/SanitizationsRunner.js"],"sourcesContent":["\"use strict\";\n/**\n * @module compiler/sanitizer\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * indicative-compiler\n *\n * (c) Harminder Virk <virk@adonisjs.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nconst isobject_1 = __importDefault(require(\"isobject\"));\nconst lodash_get_1 = __importDefault(require(\"lodash.get\"));\n/**\n * Runs an array of sanitizations on a given field.\n */\nclass SanitizationsRunner {\n    constructor(field, dotPath, rules, sanitizations) {\n        this.field = field;\n        this.dotPath = dotPath;\n        this.sanitizations = [];\n        this.computeSanitizations(sanitizations, rules);\n    }\n    /**\n     * Pull sanitizations for the list defined rules.\n     */\n    computeSanitizations(sanitizations, rules) {\n        this.sanitizations = rules.map((rule) => {\n            const sanitization = sanitizations[rule.name];\n            /**\n             * Raise exception when sanitization implementation for a\n             * given rule is missing.\n             */\n            if (!sanitization) {\n                throw new Error(`${rule.name} is not a registered as a sanitization`);\n            }\n            /**\n             * The sanitization node must have a `validate` function.\n             */\n            if (typeof (sanitization.sanitize) !== 'function') {\n                throw new Error(`${rule.name} is missing sanitize function`);\n            }\n            /**\n             * Mutate args when `compile` function is defined. It is a way to\n             * normalize arguments before the sanitization process kicks in.\n             */\n            if (typeof (sanitization.compile) === 'function') {\n                rule.args = sanitization.compile(rule.args);\n            }\n            return { rule: rule, fn: sanitization.sanitize };\n        });\n    }\n    /**\n     * Returns a fresh data copy by copying some of the values from the actual\n     * data and then mutating the `tip` and `pointer`. The tip and pointer\n     * are mutated so that the sanitization function receives the closest\n     * object from the pointer, resulting in performant code.\n     */\n    getDataCopy(data) {\n        const tip = this.dotPath.length ? lodash_get_1.default(data.tip, this.dotPath) : data.tip;\n        /**\n         * Updating the tip and pointer\n         */\n        return Object.assign({}, data, {\n            tip: this.field === '::tip::' ? { [this.field]: tip } : tip,\n        });\n    }\n    /**\n     * Execute all sanitization in series for a given filed\n     */\n    exec(data, config) {\n        const dataCopy = this.getDataCopy(data);\n        /**\n         * Skip validations when the parent value of this field is not\n         * an object. The user must validate the parent to be object\n         * seperately.\n         */\n        if (!isobject_1.default(dataCopy.tip)) {\n            return;\n        }\n        this.sanitizations.forEach((sanitization) => {\n            sanitization.fn(dataCopy, this.field, sanitization.rule.args, config);\n        });\n    }\n}\nexports.SanitizationsRunner = SanitizationsRunner;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}