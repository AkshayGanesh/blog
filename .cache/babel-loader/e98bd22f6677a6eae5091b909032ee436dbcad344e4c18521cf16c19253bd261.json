{"ast":null,"code":"'use strict';\n\n(function (global) {\n  // minimal symbol polyfill for IE11 and others\n  if (typeof Symbol !== 'function') {\n    var Symbol = function (name) {\n      return name;\n    };\n    Symbol.nonNative = true;\n  }\n  const STATE_PLAINTEXT = Symbol('plaintext');\n  const STATE_HTML = Symbol('html');\n  const STATE_COMMENT = Symbol('comment');\n  const ALLOWED_TAGS_REGEX = /<(\\w*)>/g;\n  const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n  function striptags(html, allowable_tags, tag_replacement) {\n    html = html || '';\n    allowable_tags = allowable_tags || [];\n    tag_replacement = tag_replacement || '';\n    let context = init_context(allowable_tags, tag_replacement);\n    return striptags_internal(html, context);\n  }\n  function init_striptags_stream(allowable_tags, tag_replacement) {\n    allowable_tags = allowable_tags || [];\n    tag_replacement = tag_replacement || '';\n    let context = init_context(allowable_tags, tag_replacement);\n    return function striptags_stream(html) {\n      return striptags_internal(html || '', context);\n    };\n  }\n  striptags.init_streaming_mode = init_striptags_stream;\n  function init_context(allowable_tags, tag_replacement) {\n    allowable_tags = parse_allowable_tags(allowable_tags);\n    return {\n      allowable_tags: allowable_tags,\n      tag_replacement: tag_replacement,\n      state: STATE_PLAINTEXT,\n      tag_buffer: '',\n      depth: 0,\n      in_quote_char: ''\n    };\n  }\n  function striptags_internal(html, context) {\n    if (typeof html != \"string\") {\n      throw new TypeError(\"'html' parameter must be a string\");\n    }\n    let allowable_tags = context.allowable_tags;\n    let tag_replacement = context.tag_replacement;\n    let state = context.state;\n    let tag_buffer = context.tag_buffer;\n    let depth = context.depth;\n    let in_quote_char = context.in_quote_char;\n    let output = '';\n    for (let idx = 0, length = html.length; idx < length; idx++) {\n      let char = html[idx];\n      if (state === STATE_PLAINTEXT) {\n        switch (char) {\n          case '<':\n            state = STATE_HTML;\n            tag_buffer += char;\n            break;\n          default:\n            output += char;\n            break;\n        }\n      } else if (state === STATE_HTML) {\n        switch (char) {\n          case '<':\n            // ignore '<' if inside a quote\n            if (in_quote_char) {\n              break;\n            }\n\n            // we're seeing a nested '<'\n            depth++;\n            break;\n          case '>':\n            // ignore '>' if inside a quote\n            if (in_quote_char) {\n              break;\n            }\n\n            // something like this is happening: '<<>>'\n            if (depth) {\n              depth--;\n              break;\n            }\n\n            // this is closing the tag in tag_buffer\n            in_quote_char = '';\n            state = STATE_PLAINTEXT;\n            tag_buffer += '>';\n            if (allowable_tags.has(normalize_tag(tag_buffer))) {\n              output += tag_buffer;\n            } else {\n              output += tag_replacement;\n            }\n            tag_buffer = '';\n            break;\n          case '\"':\n          case '\\'':\n            // catch both single and double quotes\n\n            if (char === in_quote_char) {\n              in_quote_char = '';\n            } else {\n              in_quote_char = in_quote_char || char;\n            }\n            tag_buffer += char;\n            break;\n          case '-':\n            if (tag_buffer === '<!-') {\n              state = STATE_COMMENT;\n            }\n            tag_buffer += char;\n            break;\n          case ' ':\n          case '\\n':\n            if (tag_buffer === '<') {\n              state = STATE_PLAINTEXT;\n              output += '< ';\n              tag_buffer = '';\n              break;\n            }\n            tag_buffer += char;\n            break;\n          default:\n            tag_buffer += char;\n            break;\n        }\n      } else if (state === STATE_COMMENT) {\n        switch (char) {\n          case '>':\n            if (tag_buffer.slice(-2) == '--') {\n              // close the comment\n              state = STATE_PLAINTEXT;\n            }\n            tag_buffer = '';\n            break;\n          default:\n            tag_buffer += char;\n            break;\n        }\n      }\n    }\n\n    // save the context for future iterations\n    context.state = state;\n    context.tag_buffer = tag_buffer;\n    context.depth = depth;\n    context.in_quote_char = in_quote_char;\n    return output;\n  }\n  function parse_allowable_tags(allowable_tags) {\n    let tag_set = new Set();\n    if (typeof allowable_tags === 'string') {\n      let match;\n      while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {\n        tag_set.add(match[1]);\n      }\n    } else if (!Symbol.nonNative && typeof allowable_tags[Symbol.iterator] === 'function') {\n      tag_set = new Set(allowable_tags);\n    } else if (typeof allowable_tags.forEach === 'function') {\n      // IE11 compatible\n      allowable_tags.forEach(tag_set.add, tag_set);\n    }\n    return tag_set;\n  }\n  function normalize_tag(tag_buffer) {\n    let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n    return match ? match[1].toLowerCase() : null;\n  }\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(function module_factory() {\n      return striptags;\n    });\n  } else if (typeof module === 'object' && module.exports) {\n    // Node\n    module.exports = striptags;\n  } else {\n    // Browser\n    global.striptags = striptags;\n  }\n})(this);","map":{"version":3,"names":["global","Symbol","name","nonNative","STATE_PLAINTEXT","STATE_HTML","STATE_COMMENT","ALLOWED_TAGS_REGEX","NORMALIZE_TAG_REGEX","striptags","html","allowable_tags","tag_replacement","context","init_context","striptags_internal","init_striptags_stream","striptags_stream","init_streaming_mode","parse_allowable_tags","state","tag_buffer","depth","in_quote_char","TypeError","output","idx","length","char","has","normalize_tag","slice","tag_set","Set","match","exec","add","iterator","forEach","toLowerCase","define","amd","module_factory","module","exports"],"sources":["/Users/akshayg/Personal/blog/blog/node_modules/striptags/src/striptags.js"],"sourcesContent":["'use strict';\n\n(function (global) {\n\n    // minimal symbol polyfill for IE11 and others\n    if (typeof Symbol !== 'function') {\n        var Symbol = function(name) {\n            return name;\n        }\n\n        Symbol.nonNative = true;\n    }\n\n    const STATE_PLAINTEXT = Symbol('plaintext');\n    const STATE_HTML      = Symbol('html');\n    const STATE_COMMENT   = Symbol('comment');\n\n    const ALLOWED_TAGS_REGEX  = /<(\\w*)>/g;\n    const NORMALIZE_TAG_REGEX = /<\\/?([^\\s\\/>]+)/;\n\n    function striptags(html, allowable_tags, tag_replacement) {\n        html            = html || '';\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return striptags_internal(html, context);\n    }\n\n    function init_striptags_stream(allowable_tags, tag_replacement) {\n        allowable_tags  = allowable_tags || [];\n        tag_replacement = tag_replacement || '';\n\n        let context = init_context(allowable_tags, tag_replacement);\n\n        return function striptags_stream(html) {\n            return striptags_internal(html || '', context);\n        };\n    }\n\n    striptags.init_streaming_mode = init_striptags_stream;\n\n    function init_context(allowable_tags, tag_replacement) {\n        allowable_tags = parse_allowable_tags(allowable_tags);\n\n        return {\n            allowable_tags : allowable_tags,\n            tag_replacement: tag_replacement,\n\n            state         : STATE_PLAINTEXT,\n            tag_buffer    : '',\n            depth         : 0,\n            in_quote_char : ''\n        };\n    }\n\n    function striptags_internal(html, context) {\n        if (typeof html != \"string\") {\n            throw new TypeError(\"'html' parameter must be a string\");\n        }\n\n        let allowable_tags  = context.allowable_tags;\n        let tag_replacement = context.tag_replacement;\n\n        let state         = context.state;\n        let tag_buffer    = context.tag_buffer;\n        let depth         = context.depth;\n        let in_quote_char = context.in_quote_char;\n        let output        = '';\n\n        for (let idx = 0, length = html.length; idx < length; idx++) {\n            let char = html[idx];\n\n            if (state === STATE_PLAINTEXT) {\n                switch (char) {\n                    case '<':\n                        state       = STATE_HTML;\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        output += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_HTML) {\n                switch (char) {\n                    case '<':\n                        // ignore '<' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // we're seeing a nested '<'\n                        depth++;\n                        break;\n\n                    case '>':\n                        // ignore '>' if inside a quote\n                        if (in_quote_char) {\n                            break;\n                        }\n\n                        // something like this is happening: '<<>>'\n                        if (depth) {\n                            depth--;\n\n                            break;\n                        }\n\n                        // this is closing the tag in tag_buffer\n                        in_quote_char = '';\n                        state         = STATE_PLAINTEXT;\n                        tag_buffer   += '>';\n\n                        if (allowable_tags.has(normalize_tag(tag_buffer))) {\n                            output += tag_buffer;\n                        } else {\n                            output += tag_replacement;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    case '\"':\n                    case '\\'':\n                        // catch both single and double quotes\n\n                        if (char === in_quote_char) {\n                            in_quote_char = '';\n                        } else {\n                            in_quote_char = in_quote_char || char;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case '-':\n                        if (tag_buffer === '<!-') {\n                            state = STATE_COMMENT;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    case ' ':\n                    case '\\n':\n                        if (tag_buffer === '<') {\n                            state      = STATE_PLAINTEXT;\n                            output    += '< ';\n                            tag_buffer = '';\n\n                            break;\n                        }\n\n                        tag_buffer += char;\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n\n            else if (state === STATE_COMMENT) {\n                switch (char) {\n                    case '>':\n                        if (tag_buffer.slice(-2) == '--') {\n                            // close the comment\n                            state = STATE_PLAINTEXT;\n                        }\n\n                        tag_buffer = '';\n                        break;\n\n                    default:\n                        tag_buffer += char;\n                        break;\n                }\n            }\n        }\n\n        // save the context for future iterations\n        context.state         = state;\n        context.tag_buffer    = tag_buffer;\n        context.depth         = depth;\n        context.in_quote_char = in_quote_char;\n\n        return output;\n    }\n\n    function parse_allowable_tags(allowable_tags) {\n        let tag_set = new Set();\n\n        if (typeof allowable_tags === 'string') {\n            let match;\n\n            while ((match = ALLOWED_TAGS_REGEX.exec(allowable_tags))) {\n                tag_set.add(match[1]);\n            }\n        }\n\n        else if (!Symbol.nonNative &&\n                 typeof allowable_tags[Symbol.iterator] === 'function') {\n\n            tag_set = new Set(allowable_tags);\n        }\n\n        else if (typeof allowable_tags.forEach === 'function') {\n            // IE11 compatible\n            allowable_tags.forEach(tag_set.add, tag_set);\n        }\n\n        return tag_set;\n    }\n\n    function normalize_tag(tag_buffer) {\n        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);\n\n        return match ? match[1].toLowerCase() : null;\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(function module_factory() { return striptags; });\n    }\n\n    else if (typeof module === 'object' && module.exports) {\n        // Node\n        module.exports = striptags;\n    }\n\n    else {\n        // Browser\n        global.striptags = striptags;\n    }\n}(this));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}